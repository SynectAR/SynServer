// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: vnarpc.proto

#include "vnarpc.pb.h"
#include "vnarpc.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace vnarpc {

static const char* VnaRpc_method_names[] = {
  "/vnarpc.VnaRpc/getPortCount",
  "/vnarpc.VnaRpc/getPortStatus",
  "/vnarpc.VnaRpc/measurePort",
  "/vnarpc.VnaRpc/measureThru",
  "/vnarpc.VnaRpc/apply",
  "/vnarpc.VnaRpc/reset",
};

std::unique_ptr< VnaRpc::Stub> VnaRpc::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< VnaRpc::Stub> stub(new VnaRpc::Stub(channel, options));
  return stub;
}

VnaRpc::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_getPortCount_(VnaRpc_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getPortStatus_(VnaRpc_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_measurePort_(VnaRpc_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_measureThru_(VnaRpc_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_apply_(VnaRpc_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_reset_(VnaRpc_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status VnaRpc::Stub::getPortCount(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::vnarpc::PortCount* response) {
  return ::grpc::internal::BlockingUnaryCall< ::vnarpc::EmptyMessage, ::vnarpc::PortCount, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getPortCount_, context, request, response);
}

void VnaRpc::Stub::async::getPortCount(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::PortCount* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::vnarpc::EmptyMessage, ::vnarpc::PortCount, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getPortCount_, context, request, response, std::move(f));
}

void VnaRpc::Stub::async::getPortCount(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::PortCount* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getPortCount_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::PortCount>* VnaRpc::Stub::PrepareAsyncgetPortCountRaw(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::vnarpc::PortCount, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getPortCount_, context, request);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::PortCount>* VnaRpc::Stub::AsyncgetPortCountRaw(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetPortCountRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status VnaRpc::Stub::getPortStatus(::grpc::ClientContext* context, const ::vnarpc::Port& request, ::vnarpc::PortStatus* response) {
  return ::grpc::internal::BlockingUnaryCall< ::vnarpc::Port, ::vnarpc::PortStatus, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getPortStatus_, context, request, response);
}

void VnaRpc::Stub::async::getPortStatus(::grpc::ClientContext* context, const ::vnarpc::Port* request, ::vnarpc::PortStatus* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::vnarpc::Port, ::vnarpc::PortStatus, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getPortStatus_, context, request, response, std::move(f));
}

void VnaRpc::Stub::async::getPortStatus(::grpc::ClientContext* context, const ::vnarpc::Port* request, ::vnarpc::PortStatus* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getPortStatus_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::PortStatus>* VnaRpc::Stub::PrepareAsyncgetPortStatusRaw(::grpc::ClientContext* context, const ::vnarpc::Port& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::vnarpc::PortStatus, ::vnarpc::Port, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getPortStatus_, context, request);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::PortStatus>* VnaRpc::Stub::AsyncgetPortStatusRaw(::grpc::ClientContext* context, const ::vnarpc::Port& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetPortStatusRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status VnaRpc::Stub::measurePort(::grpc::ClientContext* context, const ::vnarpc::MeasureParams& request, ::vnarpc::EmptyMessage* response) {
  return ::grpc::internal::BlockingUnaryCall< ::vnarpc::MeasureParams, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_measurePort_, context, request, response);
}

void VnaRpc::Stub::async::measurePort(::grpc::ClientContext* context, const ::vnarpc::MeasureParams* request, ::vnarpc::EmptyMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::vnarpc::MeasureParams, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_measurePort_, context, request, response, std::move(f));
}

void VnaRpc::Stub::async::measurePort(::grpc::ClientContext* context, const ::vnarpc::MeasureParams* request, ::vnarpc::EmptyMessage* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_measurePort_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::EmptyMessage>* VnaRpc::Stub::PrepareAsyncmeasurePortRaw(::grpc::ClientContext* context, const ::vnarpc::MeasureParams& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::vnarpc::EmptyMessage, ::vnarpc::MeasureParams, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_measurePort_, context, request);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::EmptyMessage>* VnaRpc::Stub::AsyncmeasurePortRaw(::grpc::ClientContext* context, const ::vnarpc::MeasureParams& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncmeasurePortRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status VnaRpc::Stub::measureThru(::grpc::ClientContext* context, const ::vnarpc::PortsPair& request, ::vnarpc::EmptyMessage* response) {
  return ::grpc::internal::BlockingUnaryCall< ::vnarpc::PortsPair, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_measureThru_, context, request, response);
}

void VnaRpc::Stub::async::measureThru(::grpc::ClientContext* context, const ::vnarpc::PortsPair* request, ::vnarpc::EmptyMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::vnarpc::PortsPair, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_measureThru_, context, request, response, std::move(f));
}

void VnaRpc::Stub::async::measureThru(::grpc::ClientContext* context, const ::vnarpc::PortsPair* request, ::vnarpc::EmptyMessage* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_measureThru_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::EmptyMessage>* VnaRpc::Stub::PrepareAsyncmeasureThruRaw(::grpc::ClientContext* context, const ::vnarpc::PortsPair& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::vnarpc::EmptyMessage, ::vnarpc::PortsPair, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_measureThru_, context, request);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::EmptyMessage>* VnaRpc::Stub::AsyncmeasureThruRaw(::grpc::ClientContext* context, const ::vnarpc::PortsPair& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncmeasureThruRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status VnaRpc::Stub::apply(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::vnarpc::EmptyMessage* response) {
  return ::grpc::internal::BlockingUnaryCall< ::vnarpc::EmptyMessage, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_apply_, context, request, response);
}

void VnaRpc::Stub::async::apply(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::EmptyMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::vnarpc::EmptyMessage, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_apply_, context, request, response, std::move(f));
}

void VnaRpc::Stub::async::apply(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::EmptyMessage* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_apply_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::EmptyMessage>* VnaRpc::Stub::PrepareAsyncapplyRaw(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::vnarpc::EmptyMessage, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_apply_, context, request);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::EmptyMessage>* VnaRpc::Stub::AsyncapplyRaw(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncapplyRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status VnaRpc::Stub::reset(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::vnarpc::EmptyMessage* response) {
  return ::grpc::internal::BlockingUnaryCall< ::vnarpc::EmptyMessage, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_reset_, context, request, response);
}

void VnaRpc::Stub::async::reset(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::EmptyMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::vnarpc::EmptyMessage, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_reset_, context, request, response, std::move(f));
}

void VnaRpc::Stub::async::reset(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::EmptyMessage* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_reset_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::EmptyMessage>* VnaRpc::Stub::PrepareAsyncresetRaw(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::vnarpc::EmptyMessage, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_reset_, context, request);
}

::grpc::ClientAsyncResponseReader< ::vnarpc::EmptyMessage>* VnaRpc::Stub::AsyncresetRaw(::grpc::ClientContext* context, const ::vnarpc::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncresetRaw(context, request, cq);
  result->StartCall();
  return result;
}

VnaRpc::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      VnaRpc_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< VnaRpc::Service, ::vnarpc::EmptyMessage, ::vnarpc::PortCount, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](VnaRpc::Service* service,
             ::grpc::ServerContext* ctx,
             const ::vnarpc::EmptyMessage* req,
             ::vnarpc::PortCount* resp) {
               return service->getPortCount(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      VnaRpc_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< VnaRpc::Service, ::vnarpc::Port, ::vnarpc::PortStatus, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](VnaRpc::Service* service,
             ::grpc::ServerContext* ctx,
             const ::vnarpc::Port* req,
             ::vnarpc::PortStatus* resp) {
               return service->getPortStatus(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      VnaRpc_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< VnaRpc::Service, ::vnarpc::MeasureParams, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](VnaRpc::Service* service,
             ::grpc::ServerContext* ctx,
             const ::vnarpc::MeasureParams* req,
             ::vnarpc::EmptyMessage* resp) {
               return service->measurePort(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      VnaRpc_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< VnaRpc::Service, ::vnarpc::PortsPair, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](VnaRpc::Service* service,
             ::grpc::ServerContext* ctx,
             const ::vnarpc::PortsPair* req,
             ::vnarpc::EmptyMessage* resp) {
               return service->measureThru(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      VnaRpc_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< VnaRpc::Service, ::vnarpc::EmptyMessage, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](VnaRpc::Service* service,
             ::grpc::ServerContext* ctx,
             const ::vnarpc::EmptyMessage* req,
             ::vnarpc::EmptyMessage* resp) {
               return service->apply(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      VnaRpc_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< VnaRpc::Service, ::vnarpc::EmptyMessage, ::vnarpc::EmptyMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](VnaRpc::Service* service,
             ::grpc::ServerContext* ctx,
             const ::vnarpc::EmptyMessage* req,
             ::vnarpc::EmptyMessage* resp) {
               return service->reset(ctx, req, resp);
             }, this)));
}

VnaRpc::Service::~Service() {
}

::grpc::Status VnaRpc::Service::getPortCount(::grpc::ServerContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::PortCount* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status VnaRpc::Service::getPortStatus(::grpc::ServerContext* context, const ::vnarpc::Port* request, ::vnarpc::PortStatus* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status VnaRpc::Service::measurePort(::grpc::ServerContext* context, const ::vnarpc::MeasureParams* request, ::vnarpc::EmptyMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status VnaRpc::Service::measureThru(::grpc::ServerContext* context, const ::vnarpc::PortsPair* request, ::vnarpc::EmptyMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status VnaRpc::Service::apply(::grpc::ServerContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::EmptyMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status VnaRpc::Service::reset(::grpc::ServerContext* context, const ::vnarpc::EmptyMessage* request, ::vnarpc::EmptyMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace vnarpc

