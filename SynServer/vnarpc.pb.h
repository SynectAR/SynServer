// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vnarpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vnarpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vnarpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vnarpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vnarpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vnarpc_2eproto;
namespace vnarpc {
class EmptyMessage;
struct EmptyMessageDefaultTypeInternal;
extern EmptyMessageDefaultTypeInternal _EmptyMessage_default_instance_;
class MeasureParams;
struct MeasureParamsDefaultTypeInternal;
extern MeasureParamsDefaultTypeInternal _MeasureParams_default_instance_;
class Port;
struct PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class PortCount;
struct PortCountDefaultTypeInternal;
extern PortCountDefaultTypeInternal _PortCount_default_instance_;
class PortStatus;
struct PortStatusDefaultTypeInternal;
extern PortStatusDefaultTypeInternal _PortStatus_default_instance_;
class PortsPair;
struct PortsPairDefaultTypeInternal;
extern PortsPairDefaultTypeInternal _PortsPair_default_instance_;
}  // namespace vnarpc
PROTOBUF_NAMESPACE_OPEN
template<> ::vnarpc::EmptyMessage* Arena::CreateMaybeMessage<::vnarpc::EmptyMessage>(Arena*);
template<> ::vnarpc::MeasureParams* Arena::CreateMaybeMessage<::vnarpc::MeasureParams>(Arena*);
template<> ::vnarpc::Port* Arena::CreateMaybeMessage<::vnarpc::Port>(Arena*);
template<> ::vnarpc::PortCount* Arena::CreateMaybeMessage<::vnarpc::PortCount>(Arena*);
template<> ::vnarpc::PortStatus* Arena::CreateMaybeMessage<::vnarpc::PortStatus>(Arena*);
template<> ::vnarpc::PortsPair* Arena::CreateMaybeMessage<::vnarpc::PortsPair>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vnarpc {

// ===================================================================

class EmptyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vnarpc.EmptyMessage) */ {
 public:
  inline EmptyMessage() : EmptyMessage(nullptr) {}
  ~EmptyMessage() override;
  explicit constexpr EmptyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyMessage(const EmptyMessage& from);
  EmptyMessage(EmptyMessage&& from) noexcept
    : EmptyMessage() {
    *this = ::std::move(from);
  }

  inline EmptyMessage& operator=(const EmptyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyMessage& operator=(EmptyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyMessage* internal_default_instance() {
    return reinterpret_cast<const EmptyMessage*>(
               &_EmptyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EmptyMessage& a, EmptyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmptyMessage* New() const final {
    return new EmptyMessage();
  }

  EmptyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmptyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EmptyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vnarpc.EmptyMessage";
  }
  protected:
  explicit EmptyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vnarpc.EmptyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vnarpc_2eproto;
};
// -------------------------------------------------------------------

class Port final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vnarpc.Port) */ {
 public:
  inline Port() : Port(nullptr) {}
  ~Port() override;
  explicit constexpr Port(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Port(const Port& from);
  Port(Port&& from) noexcept
    : Port() {
    *this = ::std::move(from);
  }

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  inline Port& operator=(Port&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Port& default_instance() {
    return *internal_default_instance();
  }
  static inline const Port* internal_default_instance() {
    return reinterpret_cast<const Port*>(
               &_Port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Port& a, Port& b) {
    a.Swap(&b);
  }
  inline void Swap(Port* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Port* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Port* New() const final {
    return new Port();
  }

  Port* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Port>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Port& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Port& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Port* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vnarpc.Port";
  }
  protected:
  explicit Port(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
  };
  // int32 port = 1;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vnarpc.Port)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vnarpc_2eproto;
};
// -------------------------------------------------------------------

class MeasureParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vnarpc.MeasureParams) */ {
 public:
  inline MeasureParams() : MeasureParams(nullptr) {}
  ~MeasureParams() override;
  explicit constexpr MeasureParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeasureParams(const MeasureParams& from);
  MeasureParams(MeasureParams&& from) noexcept
    : MeasureParams() {
    *this = ::std::move(from);
  }

  inline MeasureParams& operator=(const MeasureParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeasureParams& operator=(MeasureParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeasureParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeasureParams* internal_default_instance() {
    return reinterpret_cast<const MeasureParams*>(
               &_MeasureParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MeasureParams& a, MeasureParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MeasureParams* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeasureParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MeasureParams* New() const final {
    return new MeasureParams();
  }

  MeasureParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MeasureParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeasureParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MeasureParams& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeasureParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vnarpc.MeasureParams";
  }
  protected:
  explicit MeasureParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
    kPortFieldNumber = 1,
    kGenderFieldNumber = 3,
  };
  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // int32 port = 1;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool gender = 3;
  void clear_gender();
  bool gender() const;
  void set_gender(bool value);
  private:
  bool _internal_gender() const;
  void _internal_set_gender(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vnarpc.MeasureParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  bool gender_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vnarpc_2eproto;
};
// -------------------------------------------------------------------

class PortStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vnarpc.PortStatus) */ {
 public:
  inline PortStatus() : PortStatus(nullptr) {}
  ~PortStatus() override;
  explicit constexpr PortStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortStatus(const PortStatus& from);
  PortStatus(PortStatus&& from) noexcept
    : PortStatus() {
    *this = ::std::move(from);
  }

  inline PortStatus& operator=(const PortStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortStatus& operator=(PortStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortStatus* internal_default_instance() {
    return reinterpret_cast<const PortStatus*>(
               &_PortStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PortStatus& a, PortStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PortStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortStatus* New() const final {
    return new PortStatus();
  }

  PortStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vnarpc.PortStatus";
  }
  protected:
  explicit PortStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenFieldNumber = 1,
    kShortFieldNumber = 2,
    kLoadFieldNumber = 3,
    kGenderFieldNumber = 4,
  };
  // bool open = 1;
  void clear_open();
  bool open() const;
  void set_open(bool value);
  private:
  bool _internal_open() const;
  void _internal_set_open(bool value);
  public:

  // bool short = 2;
  void clear_short_();
  bool short_() const;
  void set_short_(bool value);
  private:
  bool _internal_short_() const;
  void _internal_set_short_(bool value);
  public:

  // bool load = 3;
  void clear_load();
  bool load() const;
  void set_load(bool value);
  private:
  bool _internal_load() const;
  void _internal_set_load(bool value);
  public:

  // bool gender = 4;
  void clear_gender();
  bool gender() const;
  void set_gender(bool value);
  private:
  bool _internal_gender() const;
  void _internal_set_gender(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vnarpc.PortStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool open_;
  bool short__;
  bool load_;
  bool gender_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vnarpc_2eproto;
};
// -------------------------------------------------------------------

class PortsPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vnarpc.PortsPair) */ {
 public:
  inline PortsPair() : PortsPair(nullptr) {}
  ~PortsPair() override;
  explicit constexpr PortsPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortsPair(const PortsPair& from);
  PortsPair(PortsPair&& from) noexcept
    : PortsPair() {
    *this = ::std::move(from);
  }

  inline PortsPair& operator=(const PortsPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortsPair& operator=(PortsPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortsPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortsPair* internal_default_instance() {
    return reinterpret_cast<const PortsPair*>(
               &_PortsPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PortsPair& a, PortsPair& b) {
    a.Swap(&b);
  }
  inline void Swap(PortsPair* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortsPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortsPair* New() const final {
    return new PortsPair();
  }

  PortsPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortsPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortsPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortsPair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortsPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vnarpc.PortsPair";
  }
  protected:
  explicit PortsPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstportFieldNumber = 1,
    kSecondportFieldNumber = 2,
  };
  // int32 firstport = 1;
  void clear_firstport();
  ::PROTOBUF_NAMESPACE_ID::int32 firstport() const;
  void set_firstport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_firstport() const;
  void _internal_set_firstport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 secondport = 2;
  void clear_secondport();
  ::PROTOBUF_NAMESPACE_ID::int32 secondport() const;
  void set_secondport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_secondport() const;
  void _internal_set_secondport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vnarpc.PortsPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 firstport_;
  ::PROTOBUF_NAMESPACE_ID::int32 secondport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vnarpc_2eproto;
};
// -------------------------------------------------------------------

class PortCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vnarpc.PortCount) */ {
 public:
  inline PortCount() : PortCount(nullptr) {}
  ~PortCount() override;
  explicit constexpr PortCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortCount(const PortCount& from);
  PortCount(PortCount&& from) noexcept
    : PortCount() {
    *this = ::std::move(from);
  }

  inline PortCount& operator=(const PortCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortCount& operator=(PortCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortCount* internal_default_instance() {
    return reinterpret_cast<const PortCount*>(
               &_PortCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PortCount& a, PortCount& b) {
    a.Swap(&b);
  }
  inline void Swap(PortCount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortCount* New() const final {
    return new PortCount();
  }

  PortCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortCount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vnarpc.PortCount";
  }
  protected:
  explicit PortCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortcountFieldNumber = 3,
  };
  // int32 portcount = 3;
  void clear_portcount();
  ::PROTOBUF_NAMESPACE_ID::int32 portcount() const;
  void set_portcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_portcount() const;
  void _internal_set_portcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vnarpc.PortCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 portcount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vnarpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EmptyMessage

// -------------------------------------------------------------------

// Port

// int32 port = 1;
inline void Port::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Port::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Port::port() const {
  // @@protoc_insertion_point(field_get:vnarpc.Port.port)
  return _internal_port();
}
inline void Port::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void Port::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:vnarpc.Port.port)
}

// -------------------------------------------------------------------

// MeasureParams

// int32 port = 1;
inline void MeasureParams::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureParams::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureParams::port() const {
  // @@protoc_insertion_point(field_get:vnarpc.MeasureParams.port)
  return _internal_port();
}
inline void MeasureParams::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void MeasureParams::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:vnarpc.MeasureParams.port)
}

// string type = 2;
inline void MeasureParams::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& MeasureParams::type() const {
  // @@protoc_insertion_point(field_get:vnarpc.MeasureParams.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MeasureParams::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vnarpc.MeasureParams.type)
}
inline std::string* MeasureParams::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:vnarpc.MeasureParams.type)
  return _s;
}
inline const std::string& MeasureParams::_internal_type() const {
  return type_.Get();
}
inline void MeasureParams::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MeasureParams::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MeasureParams::release_type() {
  // @@protoc_insertion_point(field_release:vnarpc.MeasureParams.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MeasureParams::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vnarpc.MeasureParams.type)
}

// bool gender = 3;
inline void MeasureParams::clear_gender() {
  gender_ = false;
}
inline bool MeasureParams::_internal_gender() const {
  return gender_;
}
inline bool MeasureParams::gender() const {
  // @@protoc_insertion_point(field_get:vnarpc.MeasureParams.gender)
  return _internal_gender();
}
inline void MeasureParams::_internal_set_gender(bool value) {
  
  gender_ = value;
}
inline void MeasureParams::set_gender(bool value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:vnarpc.MeasureParams.gender)
}

// -------------------------------------------------------------------

// PortStatus

// bool open = 1;
inline void PortStatus::clear_open() {
  open_ = false;
}
inline bool PortStatus::_internal_open() const {
  return open_;
}
inline bool PortStatus::open() const {
  // @@protoc_insertion_point(field_get:vnarpc.PortStatus.open)
  return _internal_open();
}
inline void PortStatus::_internal_set_open(bool value) {
  
  open_ = value;
}
inline void PortStatus::set_open(bool value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:vnarpc.PortStatus.open)
}

// bool short = 2;
inline void PortStatus::clear_short_() {
  short__ = false;
}
inline bool PortStatus::_internal_short_() const {
  return short__;
}
inline bool PortStatus::short_() const {
  // @@protoc_insertion_point(field_get:vnarpc.PortStatus.short)
  return _internal_short_();
}
inline void PortStatus::_internal_set_short_(bool value) {
  
  short__ = value;
}
inline void PortStatus::set_short_(bool value) {
  _internal_set_short_(value);
  // @@protoc_insertion_point(field_set:vnarpc.PortStatus.short)
}

// bool load = 3;
inline void PortStatus::clear_load() {
  load_ = false;
}
inline bool PortStatus::_internal_load() const {
  return load_;
}
inline bool PortStatus::load() const {
  // @@protoc_insertion_point(field_get:vnarpc.PortStatus.load)
  return _internal_load();
}
inline void PortStatus::_internal_set_load(bool value) {
  
  load_ = value;
}
inline void PortStatus::set_load(bool value) {
  _internal_set_load(value);
  // @@protoc_insertion_point(field_set:vnarpc.PortStatus.load)
}

// bool gender = 4;
inline void PortStatus::clear_gender() {
  gender_ = false;
}
inline bool PortStatus::_internal_gender() const {
  return gender_;
}
inline bool PortStatus::gender() const {
  // @@protoc_insertion_point(field_get:vnarpc.PortStatus.gender)
  return _internal_gender();
}
inline void PortStatus::_internal_set_gender(bool value) {
  
  gender_ = value;
}
inline void PortStatus::set_gender(bool value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:vnarpc.PortStatus.gender)
}

// -------------------------------------------------------------------

// PortsPair

// int32 firstport = 1;
inline void PortsPair::clear_firstport() {
  firstport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortsPair::_internal_firstport() const {
  return firstport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortsPair::firstport() const {
  // @@protoc_insertion_point(field_get:vnarpc.PortsPair.firstport)
  return _internal_firstport();
}
inline void PortsPair::_internal_set_firstport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  firstport_ = value;
}
inline void PortsPair::set_firstport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_firstport(value);
  // @@protoc_insertion_point(field_set:vnarpc.PortsPair.firstport)
}

// int32 secondport = 2;
inline void PortsPair::clear_secondport() {
  secondport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortsPair::_internal_secondport() const {
  return secondport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortsPair::secondport() const {
  // @@protoc_insertion_point(field_get:vnarpc.PortsPair.secondport)
  return _internal_secondport();
}
inline void PortsPair::_internal_set_secondport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  secondport_ = value;
}
inline void PortsPair::set_secondport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_secondport(value);
  // @@protoc_insertion_point(field_set:vnarpc.PortsPair.secondport)
}

// -------------------------------------------------------------------

// PortCount

// int32 portcount = 3;
inline void PortCount::clear_portcount() {
  portcount_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortCount::_internal_portcount() const {
  return portcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortCount::portcount() const {
  // @@protoc_insertion_point(field_get:vnarpc.PortCount.portcount)
  return _internal_portcount();
}
inline void PortCount::_internal_set_portcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  portcount_ = value;
}
inline void PortCount::set_portcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_portcount(value);
  // @@protoc_insertion_point(field_set:vnarpc.PortCount.portcount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vnarpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vnarpc_2eproto
